import fs
import libc
import syscall
import "parser.n" as *

// filenames_or_default returns the provided filenames or [".env"] if empty
#local
fn filenames_or_default([string] filenames):[string] {
    if filenames.len() == 0 {
        return ['.env']
    }
    return filenames
}

// load_file reads a single .env file and sets env vars.
// If overload is false, existing env vars are not overwritten.
#local
fn load_file(string filename, bool overload_):void! {
    var env_map = read_file(filename)

    // get current environment variable keys
    var raw_env = libc.get_envs()
    {string:bool} current_env = {}
    for raw_line in raw_env {
        var eq_idx = find_char_index(raw_line, '='[0])
        if eq_idx > 0 {
            current_env[raw_line[..eq_idx]] = true
        }
    }

    for key, value in env_map {
        if !current_env.contains(key) || overload_ {
            libc.setenv(key.to_cstr(), value.to_cstr(), 1)
        }
    }
}

// read_file reads a single .env file and returns its key-value pairs
#local
fn read_file(string filename):{string:string}! {
    var f = fs.open(filename, syscall.O_RDONLY, 0)
    var content = f.content()
    f.close()
    {string:string} out = {}
    parse_bytes(content, out)
    return out
}

// double_quote_escape escapes special characters for double-quoted .env values
#local
fn double_quote_escape(string line):string {
    var result = line
    // order matters: backslash first
    result = replace_all(result, '\\', '\\\\')
    result = replace_all(result, '\n', '\\n')
    result = replace_all(result, '\r', '\\r')
    result = replace_all(result, '"', '\\"')
    result = replace_all(result, '!', '\\!')
    result = replace_all(result, '$', '\\$')
    result = replace_all(result, '`', '\\`')
    return result
}

// is_integer checks if a string represents a pure integer (optional leading minus)
#local
fn is_integer(string s):bool {
    if s.len() == 0 {
        return false
    }
    var start = 0
    if s[0] == '-'[0] || s[0] == '+'[0] {
        start = 1
    }
    if start >= s.len() {
        return false
    }
    for int i = start; i < s.len(); i += 1 {
        if !is_digit(s[i]) {
            return false
        }
    }
    return true
}

// sort_strings sorts a string array in-place using bubble sort
#local
fn sort_strings([string] arr) {
    var n = arr.len()
    for int i = 0; i < n - 1; i += 1 {
        for int j = 0; j < n - i - 1; j += 1 {
            if arr[j] > arr[j + 1] {
                (arr[j], arr[j + 1]) = (arr[j + 1], arr[j])
            }
        }
    }
}

// join_strings joins a string array with a separator
#local
fn join_strings([string] arr, string sep):string {
    if arr.len() == 0 {
        return ''
    }
    var result = arr[0]
    for int i = 1; i < arr.len(); i += 1 {
        result += sep + arr[i]
    }
    return result
}

#local
fn get_raw(string key):string! {
    var val = libc.getenv(key.to_cstr())
    if val as anyptr == 0 as anyptr {
        throw errorf('environment variable "%s" is not set', key)
    }
    return val.to_string()
}

#local
fn parse_bool(string s):bool! {
    var lower = to_lower(s)
    if lower == 'true' || lower == '1' || lower == 'yes' {
        return true
    }
    if lower == 'false' || lower == '0' || lower == 'no' {
        return false
    }
    throw errorf('cannot parse "%s" as bool (expected true/false/1/0/yes/no)', s)
}

#local
fn parse_dict(string s):{string:string}! {
    {string:string} result = {}
    var pairs = split_and_trim(s, ','[0])
    for int i = 0; i < pairs.len(); i += 1 {
        var pair = pairs[i]
        if pair.len() == 0 {
            continue
        }
        var eq_pos = -1
        for int j = 0; j < pair.len(); j += 1 {
            if pair[j] == '='[0] {
                eq_pos = j
                break
            }
        }
        if eq_pos < 0 {
            throw errorf('invalid key=value pair: "%s"', pair)
        }
        var k = trim_spaces(pair[0..eq_pos])
        var v = trim_spaces(pair[eq_pos + 1..])
        result[k] = v
    }
    return result
}

#local
fn to_lower(string s):string {
    [u8] result = []
    for int i = 0; i < s.len(); i += 1 {
        var c = s[i]
        if c >= 65 && c <= 90 {
            result.push(c + 32)
        } else {
            result.push(c)
        }
    }
    return result as string
}

#local
fn split_and_trim(string s, u8 delim):[string] {
    [string] parts = []
    var start = 0
    for int i = 0; i < s.len(); i += 1 {
        if s[i] == delim {
            parts.push(trim_spaces(s[start..i]))
            start = i + 1
        }
    }
    parts.push(trim_spaces(s[start..]))
    return parts
}

#local
fn is_space(u8 c):bool {
    return c == ' '[0] || c == '\t'[0] || c == '\r'[0] || c == 11 || c == 12
}

#local
fn trim_spaces(string s):string {
    var left = 0
    for left < s.len() && is_space(s[left]) {
        left += 1
    }
    var right = s.len()
    for right > left && (is_space(s[right - 1]) || s[right - 1] == '\n'[0]) {
        right -= 1
    }
    if left == 0 && right == s.len() {
        return s
    }
    return s[left..right]
}
