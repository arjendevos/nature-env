// test_comments.n - Tests comment handling
import "lib.n" as *
import "assert.n" as *

fn main():void! {
    println('--- test_comments ---')

    // Full-line comments are skipped
    test_start('full line comment skipped')
    var r1 = unmarshal('# comment\nKEY=value')
    assert_eq_int(r1.len(), 1)
    assert_eq(r1['KEY'], 'value')

    // Multiple comments
    test_start('multiple comments')
    var r2 = unmarshal('# first\n# second\nKEY=value')
    assert_eq(r2['KEY'], 'value')

    // Inline comments (# preceded by space)
    test_start('inline comment')
    var r3 = unmarshal('KEY=value # this is a comment')
    assert_eq(r3['KEY'], 'value')

    // Hash without preceding space is NOT a comment
    test_start('hash without space is not comment')
    var r4 = unmarshal('KEY=value#notacomment')
    assert_eq(r4['KEY'], 'value#notacomment')

    // Empty lines are skipped
    test_start('empty lines skipped')
    var r5 = unmarshal('\n\nKEY1=val1\n\nKEY2=val2\n\n')
    assert_eq_int(r5.len(), 2)
    assert_eq(r5['KEY1'], 'val1')
    assert_eq(r5['KEY2'], 'val2')

    // Only comments - empty result
    test_start('only comments returns empty map')
    var r6 = unmarshal('# only\n# comments')
    assert_eq_int(r6.len(), 0)

    // Read from fixture
    test_start('read comments.env fixture')
    var file_result = read(['fixtures/comments.env'])
    assert_eq(file_result['KEY1'], 'value1')
    assert_eq(file_result['KEY2'], 'value2')
    assert_eq(file_result['KEY3'], 'value3')
    assert_eq(file_result['KEY4'], 'value4')
    assert_eq(file_result['KEY5'], 'value5# no space before hash is NOT a comment')

    var ok = test_summary('test_comments')
    if !ok {
        throw errorf('test_comments failed')
    }
}
