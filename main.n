import fs
import fmt
import libc
import strings
import syscall

import "parser.n" as *
import "utils.n" as *

const DOUBLE_QUOTE_SPECIAL_CHARS = '\\\n\r"!$`'

// unmarshal reads an env string and returns a map of keys and values.
fn unmarshal(string src):{string:string}! {
    return unmarshal_bytes(src)
}

// unmarshal_bytes parses env file content, returning a map of keys and values.
fn unmarshal_bytes(string src):{string:string}! {
    {string:string} out = {}
    parse_bytes(src, out)
    return out
}

// read reads all env vars from the specified files and returns them as a map
// without loading them into the process environment.
// If no filenames given, defaults to ".env".
fn read(...[string] filenames):{string:string}! {
    var fnames = filenames_or_default(filenames)
    {string:string} env_map = {}

    for fname in fnames {
        var individual = read_file(fname)
        for k, v in individual {
            env_map[k] = v
        }
    }

    return env_map
}

// load reads env file(s) and loads them into the process environment.
// It WILL NOT override env variables that already exist.
// If no filenames given, defaults to ".env".
// Panics on failure.
fn load(...[string] filenames):bool {
    var fnames = filenames_or_default(filenames)
    for fname in fnames {
        load_file(fname, false) catch err {
            panic(fmt.sprintf('failed to load env file "%s": %s', fname, err.msg()))
        }
    }
    return true
}

// overload reads env file(s) and loads them into the process environment.
// It WILL override env variables that already exist.
// If no filenames given, defaults to ".env".
// Panics on failure.
fn overload(...[string] filenames):bool {
    var fnames = filenames_or_default(filenames)
    for fname in fnames {
        load_file(fname, true) catch err {
            panic(fmt.sprintf('failed to load env file "%s": %s', fname, err.msg()))
        }
    }
    return true
}

// write serializes the given environment map and writes it to a file.
// Each line is in the format: KEY="VALUE" (with escaping) or KEY=123 for integers.
fn write({string:string} env_map, string filename):void! {
    var content = marshal(env_map) + '\n'
    var f = fs.open(filename, syscall.O_WRONLY | syscall.O_CREAT | syscall.O_TRUNC, 0o644)
    f.write(content as [u8])
    f.close()
}

// marshal outputs the given environment map as a dotenv-formatted string.
// Each line is in the format: KEY="VALUE" where VALUE is backslash-escaped,
// or KEY=VALUE for pure integer values.
fn marshal({string:string} env_map):string {
    [string] lines = []

    for k, v in env_map {
        if is_integer(v) {
            lines.push(k + '=' + v)
        } else {
            lines.push(k + '="' + double_quote_escape(v) + '"')
        }
    }

    sort_strings(lines)
    return join_strings(lines, '\n')
}

// --- Typed getters ---

// text retrieves an env var as a string.
// Throws if not set and no default is provided.
//   env.text('HOST')              → throws if missing
//   env.text('HOST', 'localhost') → returns 'localhost' if missing
fn text(string key, ...[string] fallback):string! {
    var val = libc.getenv(key.to_cstr())
    if val as anyptr == 0 as anyptr {
        if fallback.len() > 0 {
            return fallback[0]
        }
        throw errorf('environment variable "%s" is not set', key)
    }
    return val.to_string()
}

// str is an alias for text.
fn str(string key, ...[string] fallback):string! {
    return text(key, ...fallback)
}

// number retrieves an env var as an int.
// Throws if not set (and no default) or not a valid integer.
//   env.number('PORT')        → throws if missing
//   env.number('PORT', 3000)  → returns 3000 if missing
fn number(string key, ...[int] fallback):int! {
    var val = libc.getenv(key.to_cstr())
    if val as anyptr == 0 as anyptr {
        if fallback.len() > 0 {
            return fallback[0]
        }
        throw errorf('environment variable "%s" is not set', key)
    }
    return val.to_string().to_int()
}

// decimal retrieves an env var as a float.
// Throws if not set (and no default) or not a valid float.
//   env.decimal('RATE')       → throws if missing
//   env.decimal('RATE', 0.5)  → returns 0.5 if missing
fn decimal(string key, ...[float] fallback):float! {
    var val = libc.getenv(key.to_cstr())
    if val as anyptr == 0 as anyptr {
        if fallback.len() > 0 {
            return fallback[0]
        }
        throw errorf('environment variable "%s" is not set', key)
    }
    return val.to_string().to_float()
}

// boolean retrieves an env var as a bool.
// Accepts: true/false, 1/0, yes/no (case-insensitive).
// Throws if not set (and no default) or not a valid bool.
//   env.boolean('DEBUG')         → throws if missing
//   env.boolean('DEBUG', false)  → returns false if missing
fn boolean(string key, ...[bool] fallback):bool! {
    var val = libc.getenv(key.to_cstr())
    if val as anyptr == 0 as anyptr {
        if fallback.len() > 0 {
            return fallback[0]
        }
        throw errorf('environment variable "%s" is not set', key)
    }
    return parse_bool(val.to_string())
}

// array retrieves an env var as a string array, split by comma with whitespace trimmed.
// Throws if not set and no defaults are provided.
// The variadic args serve as the default array:
//   env.array('TAGS')                 → throws if missing
//   env.array('TAGS', 'a', 'b', 'c') → returns ['a','b','c'] if missing
fn array(string key, ...[string] fallback):[string]! {
    var val = libc.getenv(key.to_cstr())
    if val as anyptr == 0 as anyptr {
        if fallback.len() > 0 {
            return fallback
        }
        throw errorf('environment variable "%s" is not set', key)
    }
    return split_and_trim(val.to_string(), ','[0])
}

// dict retrieves an env var as a {string:string} map, parsing comma-separated key=value pairs.
// Example: "host=localhost,port=5432" → {"host": "localhost", "port": "5432"}
// Throws if not set and no default is provided.
//   env.dict('DB_OPTS')                                     → throws if missing
//   env.dict('DB_OPTS', 'host=localhost,port=5432')          → returns parsed fallback if missing
fn dict(string key, ...[string] fallback):{string:string}! {
    var val = libc.getenv(key.to_cstr())
    if val as anyptr == 0 as anyptr {
        if fallback.len() > 0 {
            return parse_dict(fallback[0])
        }
        throw errorf('environment variable "%s" is not set', key)
    }
    return parse_dict(val.to_string())
}

