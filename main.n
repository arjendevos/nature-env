// nature-env: A dotenv file parser and loader for nature-lang
//
// Inspired by godotenv (https://github.com/joho/godotenv)
//
// Create a .env file:
//
//     DATABASE_URL=postgres://localhost/mydb
//     SECRET_KEY=mysecret
//     DEBUG=true
//
// Then in your nature code:
//
//     import nature_env
//     import nature_env.env as env
//
//     fn main():void! {
//         nature_env.load()         // loads .env by default
//         var port = env.int('PORT')
//         var debug = env.bool('DEBUG')
//     }

import fs
import libc
import strings
import syscall
import "parser.n" as *

const DOUBLE_QUOTE_SPECIAL_CHARS = '\\\n\r"!$`'

// unmarshal reads an env string and returns a map of keys and values.
fn unmarshal(string src):{string:string}! {
    return unmarshal_bytes(src)
}

// unmarshal_bytes parses env file content, returning a map of keys and values.
fn unmarshal_bytes(string src):{string:string}! {
    {string:string} out = {}
    parse_bytes(src, out)
    return out
}

// read reads all env vars from the specified files and returns them as a map
// without loading them into the process environment.
// If no filenames given, defaults to ".env".
fn read(...[string] filenames):{string:string}! {
    var fnames = filenames_or_default(filenames)
    {string:string} env_map = {}

    for fname in fnames {
        var individual = read_file(fname)
        for k, v in individual {
            env_map[k] = v
        }
    }

    return env_map
}

// load reads env file(s) and loads them into the process environment.
// It WILL NOT override env variables that already exist.
// If no filenames given, defaults to ".env".
fn load(...[string] filenames):void! {
    var fnames = filenames_or_default(filenames)
    for fname in fnames {
        load_file(fname, false)
    }
}

// overload reads env file(s) and loads them into the process environment.
// It WILL override env variables that already exist.
// If no filenames given, defaults to ".env".
fn overload(...[string] filenames):void! {
    var fnames = filenames_or_default(filenames)
    for fname in fnames {
        load_file(fname, true)
    }
}

// write serializes the given environment map and writes it to a file.
// Each line is in the format: KEY="VALUE" (with escaping) or KEY=123 for integers.
fn write({string:string} env_map, string filename):void! {
    var content = marshal(env_map) + '\n'
    var f = fs.open(filename, syscall.O_WRONLY | syscall.O_CREAT | syscall.O_TRUNC, 0o644)
    f.write(content as [u8])
    f.close()
}

// marshal outputs the given environment map as a dotenv-formatted string.
// Each line is in the format: KEY="VALUE" where VALUE is backslash-escaped,
// or KEY=VALUE for pure integer values.
fn marshal({string:string} env_map):string {
    [string] lines = []

    for k, v in env_map {
        if is_integer(v) {
            lines.push(k + '=' + v)
        } else {
            lines.push(k + '="' + double_quote_escape(v) + '"')
        }
    }

    sort_strings(lines)
    return join_strings(lines, '\n')
}

// -- Internal helpers --

// filenames_or_default returns the provided filenames or [".env"] if empty
fn filenames_or_default([string] filenames):[string] {
    if filenames.len() == 0 {
        return ['.env']
    }
    return filenames
}

// load_file reads a single .env file and sets env vars.
// If overload is false, existing env vars are not overwritten.
fn load_file(string filename, bool overload_):void! {
    var env_map = read_file(filename)

    // get current environment variable keys
    var raw_env = libc.get_envs()
    {string:bool} current_env = {}
    for raw_line in raw_env {
        var eq_idx = find_char_index(raw_line, '='[0])
        if eq_idx > 0 {
            current_env[raw_line[..eq_idx]] = true
        }
    }

    for key, value in env_map {
        if !current_env.contains(key) || overload_ {
            libc.setenv(key.to_cstr(), value.to_cstr(), 1)
        }
    }
}

// read_file reads a single .env file and returns its key-value pairs
fn read_file(string filename):{string:string}! {
    var f = fs.open(filename, syscall.O_RDONLY, 0)
    var content = f.content()
    f.close()
    return unmarshal_bytes(content)
}

// double_quote_escape escapes special characters for double-quoted .env values
fn double_quote_escape(string line):string {
    var result = line
    // order matters: backslash first
    result = replace_all(result, '\\', '\\\\')
    result = replace_all(result, '\n', '\\n')
    result = replace_all(result, '\r', '\\r')
    result = replace_all(result, '"', '\\"')
    result = replace_all(result, '!', '\\!')
    result = replace_all(result, '$', '\\$')
    result = replace_all(result, '`', '\\`')
    return result
}

// is_integer checks if a string represents a pure integer (optional leading minus)
fn is_integer(string s):bool {
    if s.len() == 0 {
        return false
    }
    var start = 0
    if s[0] == '-'[0] || s[0] == '+'[0] {
        start = 1
    }
    if start >= s.len() {
        return false
    }
    for int i = start; i < s.len(); i += 1 {
        if !is_digit(s[i]) {
            return false
        }
    }
    return true
}

// sort_strings sorts a string array in-place using bubble sort
fn sort_strings([string] arr) {
    var n = arr.len()
    for int i = 0; i < n - 1; i += 1 {
        for int j = 0; j < n - i - 1; j += 1 {
            if arr[j] > arr[j + 1] {
                (arr[j], arr[j + 1]) = (arr[j + 1], arr[j])
            }
        }
    }
}

// join_strings joins a string array with a separator
fn join_strings([string] arr, string sep):string {
    if arr.len() == 0 {
        return ''
    }
    var result = arr[0]
    for int i = 1; i < arr.len(); i += 1 {
        result += sep + arr[i]
    }
    return result
}
